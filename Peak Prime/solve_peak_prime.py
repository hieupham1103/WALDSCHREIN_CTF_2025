# Solver for the CTF challenge in peak_prime.py using leaked high bits of q
# Given n, e, cypher, and peak = bin(q >> 25), recover q, p, and decrypt.

from math import ceil
from sympy import nextprime

# Provided constants from the challenge (from the triple-quoted block)
cypher = 54542475235946298304895744059835459839757996962840139451571868152159283433377528113776276213114574919856504898944614587402355946688040276521749552690606974662114963126716853767825180301099416456021243380508951649086076356936471503771942124456742735341827554381116980515013638434918044455446725939801559301936
n = 85164716461916154411765778764912592182877871841077273307676207049879017163803398718235334236141728848744729459255847383987751918496290831509336883267410241339747535777342199093301316906118697682261375372859060381406570022862018652011767500144901804230770970657635346842786961155693408304413618396284786917097
peak_str = "0b1001100111011010011001100101100010001010011000000100101011010111100010010010110110000111010101100110110101100110100000101010111011110100011100001010101011011100011001111101101111101110101010111011000110010111101011111101100010000011000111111101100010100111100101011011101100101001101111101001100101011111110101001111010100011100101001000011011110100100011100011100110100111000010111011010110101111110000111111010001110111110000001010011000011111101110100100110011111000011110000001100001"

# Parameters
UNKNOWN_BITS = 25
E = 65537

# Reconstruct the known high bits of q
q_high = int(peak_str, 2)
q_min = q_high << UNKNOWN_BITS
q_max = (q_high << UNKNOWN_BITS) | ((1 << UNKNOWN_BITS) - 1)

# Iterate over primes in the range [q_min, q_max] using sympy.nextprime
q = q_min - 1
found_q = None

while True:
    q = nextprime(q)
    if q > q_max:
        break
    if n % q == 0:
        found_q = q
        break

if found_q is None:
    raise SystemExit("Failed to find q in the candidate range. Try a different approach or verify inputs.")

q = found_q
p = n // q
assert p * q == n

# Compute private exponent d
phi = (p - 1) * (q - 1)
# Python 3.8+: pow with -1 exponent computes modular inverse
d = pow(E, -1, phi)

m = pow(cypher, d, n)
# Convert integer to bytes (big-endian)
length = (m.bit_length() + 7) // 8
flag_bytes = m.to_bytes(length, 'big')

print(flag_bytes)
try:
    print(flag_bytes.decode())
except Exception:
    pass
